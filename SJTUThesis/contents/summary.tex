% !TEX root = ../main.tex

\chapter{全文总结} \label{ch:summary}

\section{主要结论}

本文对基于静态单赋值中间语言的函数式编译器验证做了初步研究。
此研究的关键在于提供一个经验证的从CPS到SSA的转换算法，从而将经验证的函数编译器与经验证的SSA基础设施连接起来。
我们设计了这样一种算法，它以CPS形式的PCF程序作为输入，输出LLVM风格的SSA程序。
然后，我们为源程序和目标程序提供了小步操作语义，并基于模拟技术对转换算法的正确性进行了形式化验证。
本文工作解决了从CPS到SSA转换算法的形式化验证这一开放问题，为设计高效可靠的函数式编译器提供了新思路。
基于该经验证的编译过程，我们还构建了一个目标语言是LLVM IR的PCF编译器。
它先将读入的直接风格PCF程序转换为CPS形式，再编译到SSA目标语言，并进一步编译到Vellvm抽象语法树，得到LLVM IR程序。
这为未来使经验证的函数编译器利用基于静态单赋值中间语言的编译器基础设施提供了基础。

\section{研究展望}

当前函数式语言的设计中，程序项中使用有名字的变量表示方法。
在这种表示方法中，每个变量都有一个唯一的名称，通常是字符串或符号。
这种表示方法使代码项容易被人类理解，但在处理绑定变量时可能会引入名称冲突，需要进行重命名。
并且，这种表示方式使程序语言某些性质的证明更加困难。
如果在未来使用局部无命名表示（Locally Nameless Representation），变量就不具有全局唯一的名称，
而是使用一种特殊的标记：将绑定变量表示为de Bruijn形式的索引，从而避免了$\alpha$等价类的引入。
而自由变量保持为有名字的表示方式。如果能够实现这种改进，就可以避免对源程序使用$\alpha$重命名，
并且更方便地对代码项的类型性质进行证明。

由于本文在经验证的编译器领域实现了CPS与SSA的链接，在未来经验证的函数式编译器可以基于
本文的工作将更加现实的函数式语言编译到LLVM IR，从而复用其后端提供的各种工具。
不过，由于Vellvm现在已经将LLVM IR的语义从操作语义转向了基于ITree的语义~\cite{itree2019,itreevellvm2021}，
如果想要使用Vellvm的后续工作，可以着手于将操作语义与基于ITree的语义进行链接。
